# 一个链表 ，翻转 m 到 n 的节点；
# 给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。
# 有n个数，其范围是1-n，其中有些数出现一次，有些数出现两次，请问怎么把出现两次的找出来
1. 对每个数代表的位置上进行标记 - 号
2. 最后遍历剩下的带 - 号的位，即代表出现一次的
# n个整数的无序数组，找到每个元素后面比它大的第一个数，要求时间复杂度为O(N)
```c++
#include <bits/stdc++.h>
using namespace std;

vector<int> find1(vector<int>num)
{
    if(num.size() == 0) return {};
    vector<int> res(num.size(),-1);	//找不到设为-1
    stack<int> s;
    int i = 0;
    while(i < num.size())
    {
        if(s.empty() || num[s.top()] >= num[i])     s.push(i++); //当前元素比栈顶元素小，加入单调栈中
        else        
        {
            res[s.top()] = num[i]; //当前元素是栈顶元素后面的第一个较大元素，加入结果中
            s.pop();
        }
    }
    return res;
}

int main()
{
    vector<int> num = {1, 3, 2, 4, 99, 101, 5, 8};
    vector<int> res = find1(num);
    for(auto i : res)
        cout << i << "  ";
    return 0;
}
```
# 贪心算法与动态规划的关系
1. 动态规划
   1. 动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。
   2. 能采用动态规划求解的问题的一般要具有3个性质：
    （1）最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
    （2）无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
    （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没果这条性质，动态规划算法同其他算法相比就不具备优势）
2. 贪心算法
   1. 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。因而贪心算法不是对所有问题都能得到整体最优解（也就是说这样的问题贪心算法就不适用，可以用动态规划），例如01背包问题就不能用贪心算法求解(因为01背包问题不具备贪心选择性质----通过局部最优，达不到全局最优)，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。
   2. 能用贪心算法解决的问题理论上都可以利用动态规划解决，而一旦证明贪心选择性质，用贪心算法解决问题比动态规划具有更低的时间复杂度和空间复杂度，如果一个问题有一部分情况是不满足这个策略的，这时候就只能用动态规划了。
